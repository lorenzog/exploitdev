#!/usr/bin/env python
"""
Generates a pattern made of unique sequences and finds a sequence in it.

Author: github.com/lorenzog

"""
from __future__ import print_function
import codecs
import argparse
from itertools import permutations
import logging
import math
import string

log = logging.getLogger(__name__)
log.addHandler(logging.StreamHandler())
log.setLevel(logging.INFO)


DEFAULT_LEN = 4096
ALPHABET = string.ascii_letters + string.digits
DEFAULT_PERMUTATIONS_LEN = 4


def gen_pattern(pattern_len=DEFAULT_LEN):
    print("Generating pattern of length: {}".format(pattern_len))
    # generate all possible permutations
    pgen = permutations(ALPHABET, DEFAULT_PERMUTATIONS_LEN)
    haystack_l = list()
    # because of the divison / DEFAULT_PERMUTATIONS_LEN,
    # the pattern could end up 3 character short if the permutation len is 4
    # so we round it up here
    for i in range(int(
        math.ceil(float(pattern_len)/DEFAULT_PERMUTATIONS_LEN))
    ):
        next_seq = next(pgen)
        haystack_l.extend(next_seq)

    haystack = ''.join(haystack_l)
    # ... and we trim it here
    return haystack[:pattern_len]


def find_needle(haystack, needle, little_endian=True):
    # inspired by: https://github.com/Svenito/exploit-pattern, thanks!
    if needle.startswith('0x'):
        print("Hex pattern detected, turning into ASCII")
        needle = codecs.decode(needle[2:], "hex")
        log.debug("Decoded: {}".format(repr(needle)))
        # needle = bytes.fromhex(needle).decode('ascii')
        # needle = needle[::-1]
        if little_endian:
            needle = needle[::-1]
            log.debug("Inverted from little endian: {}".format(repr(needle)))
        print("Looking for pattern {} in haystack".format(needle))

    if len(needle) < DEFAULT_PERMUTATIONS_LEN:
        print("Warning: needle too short to be unique. "
              "This will return the first occurrence of "
              "the pattern, not its exact location")
    # find it
    found = haystack.find(needle)
    if found == -1:
        # see if the end matches? maybe the pattern is too short
        print("Full needle not found, trying a shorter version at the end...")
        found = haystack[-3:].find(needle[:3])
        if found > -1:
            print(
                "Last 3 characters of pattern {} found at the end of the "
                "haystack.".format(needle[:3]))
        else:
            found = haystack[-2:].find(needle[:2])
            if found > -1:
                print("Last 2 characters of pattern {} found at the end "
                      "of the haystack.".format(needle[:2]))
            else:
                print("Pattern {} not found".format(needle))
    else:
        print("Pattern {} found at {}".format(needle, found))


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-l', '--len', type=int, default=DEFAULT_LEN)
    parser.add_argument('-n', '--needle')
    parser.add_argument('--big-endian',
                        action='store_true',
                        help="If pattern is in hex, don't invert")
    parser.add_argument('-d', '--debug', action='store_true')
    args = parser.parse_args()

    if args.debug:
        log.setLevel(logging.DEBUG)

    haystack = gen_pattern(args.len)
    if args.needle is None:
        print(haystack)
    else:
        print("Looking for needle {} in haystack of length: {}".format(
            args.needle, len(haystack)))
        if args.big_endian:
            little_endian = False
        else:
            little_endian = True
        find_needle(haystack, args.needle, little_endian)


if __name__ == '__main__':
    main()
