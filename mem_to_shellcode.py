#!/usr/bin/env python
"""
Turns a memory dump into shellcode

Author: github.com/lorenzog

"""
from __future__ import print_function
import argparse
import struct
import logging

log = logging.getLogger(__name__)
log.addHandler(logging.StreamHandler())
log.setLevel(logging.INFO)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('memory_dump')
    parser.add_argument('-d', '--debug', action='store_true')
    parser.add_argument('-o', '--output')
    args = parser.parse_args()

    if args.debug:
        log.setLevel(logging.DEBUG)

    with open(args.memory_dump) as f:
        opcodes = f.read()

    opcodes_list_le = opcodes.split()
    print("Opcodes start with.. {}".format(opcodes_list_le[:10]))
    if len(opcodes_list_le) % 2 == 1:
        raise SystemExit("Opcodes not even: {}".format(len(opcodes_list_le)))
    opcodes_list = opcodes_list_le

    # was: swap bytes 2 by t2
    # opcodes_list = list()
    # for i in range(0, len(opcodes_list_le), 2):
    #     # swap 2 by 2
    #     opcodes_list.append(opcodes_list_le[i+1])
    #     opcodes_list.append(opcodes_list_le[i])

    opcodes_bytes = list()
    for o in opcodes_list:
        opcodes_bytes.append(struct.pack("!B", int(o, base=16)))

    print("Opcodes bytes start with.. {}".format(opcodes_bytes[:10]))

    if args.output is not None:
        with open(args.output, 'w') as f:
            f.write(bytearray(opcodes_bytes))
        print("Bytes written to file.")


if __name__ == '__main__':
    main()
